# ruff: noqa: G004
import logging
import re
from pathlib import Path
from pprint import pprint

import environ
import inflect
import yaml
from django.conf import settings
from django.core.management.base import BaseCommand

env = environ.Env()
logger = logging.getLogger(__name__)
p = inflect.engine()

try:
    from yaml import CDumper as Dumper
    from yaml import CLoader as Loader

    logger.debug("Successfully imported pyyaml CDumper and CLoader.")
except ImportError:
    from yaml import Dumper
    from yaml import Loader

    logger.warning(
        "Failed to import pyyaml CDumper and CLoader, loads and dumps of YAML may take much longer."  # noqa: E501
    )


class Command(BaseCommand):
    ignored_files = ["tournamentRuleSets.yaml", "translationLanguages.yaml"]

    def add_arguments(self, parser):
        parser.add_argument(
            "--target",
            help="target directory holding the sde yaml files",
        )
        parser.add_argument(
            "--output",
            help="output directory for the generated models",
        )

    def handle(self, *args, **options):
        target_dir = Path(options["target"])
        output_dir = Path(options["output"])

        logger.info(f"Target directory: {target_dir}")
        logger.info(f"Output directory: {output_dir}")

        yaml_files = [
            entry
            for entry in target_dir.iterdir()
            if entry.suffix in [".yaml", ".yml"]
            and entry.is_file()
            and entry.name.split("/")[-1] not in self.ignored_files
        ]

        # print(yaml_files)
        # with output_dir.joinpath("__init__.py").open("w") as initfile:
        #     initfile.write(
        #         "# this file is autogenerated by python manage.py sde_gen_models, do not edit it!\n\n"
        #     )
        for yf in yaml_files:
            logger.info(f"Processing {yf.name}")
            model_name = self._convert_to_snake_case(yf.name.split(".")[0])
            data = self._load_yaml(yf)

            pprint(data)

            fields = self._extract_fields_from_yaml(data)

            lines = []

            lines.append("from django.db import models")
            lines.append("")
            lines.append("")
            lines.append(
                f"class {self._convert_to_signular_noun(self._convert_to_pascel_case(model_name))}(models.Model):"
            )
            for field_name, field_type in fields.items():
                lines.append(f"    {field_name} = {field_type}")
            lines.append("")
            lines.append("    def __str__(self):")
            if "name_id" in fields:
                lines.append(f'        return f"{{self.name_id["en"]}}"')
            else:
                lines.append(f'        return f"{{self.id}}"')

            # end of file
            lines.append("")

            # print("\n".join(lines))
            with output_dir.joinpath(f"{model_name}.py").open("w") as f:
                f.write("\n".join(lines))

            # TODO: get all models and add them to the __init__.py file
            # initfile.write(
            #     f"from .{model_name} import {self._convert_to_signular_noun(self._convert_to_pascel_case(model_name))}\n"
            # )

    def _convert_to_snake_case(self, name):
        """Convert a string to snake_case."""
        if isinstance(name, int):
            return name
        s = re.sub(r"([a-z])([A-Z])", r"\1_\2", name)
        return s.lower()

    def _convert_to_pascel_case(self, name):
        """Convert a string to PascalCase."""
        if isinstance(name, int):
            return name
        return "".join(word.title() for word in name.split("_"))

    def _load_yaml(self, p: Path):
        logger.debug(f"parsing yaml file at {p.absolute().resolve()!s}")
        with p.open("r") as t:
            return yaml.load(t.read(), Loader=Loader)

    def _is_complex_type(self, field_type):
        """Check if the field type is complex."""
        return isinstance(field_type, (list, dict))

    def _convert_to_signular_noun(self, name):
        """Convert a string to singular noun."""
        word = p.singular_noun(name)
        if not word:
            logger.warning(f"Failed to convert {name} to singular noun.")
            return name
        return word

    def _get_field_type(self, field_value, optional):
        """Determine the Django field type based on the value."""
        if self._is_complex_type(field_value):
            if isinstance(field_value, list):
                if optional:
                    return "models.JSONField(default=list, null=True, blank=True)"
                return "models.JSONField()"
            else:
                if optional:
                    return "models.JSONField(default=dict, null=True, blank=True)"
                return "models.JSONField()"
        elif isinstance(field_value, bool):
            if optional:
                return "models.BooleanField(default=False, null=True, blank=True)"
            return "models.BooleanField()"
        elif isinstance(field_value, int):
            if optional:
                return "models.IntegerField(default=None, null=True, blank=True)"
            return "models.IntegerField()"
        elif isinstance(field_value, float):
            if optional:
                return "models.FloatField(default=None, null=True, blank=True)"
            return "models.FloatField()"
        else:
            if optional:
                return "models.TextField(default=None)"
            return "models.TextField()"

    def _extract_fields_from_yaml(self, yaml_data):
        """Extract fields from the YAML data."""
        fields = {}
        field_types = {}
        field_found = {}

        for item in yaml_data:
            print(f"item: {item}")
            if (
                isinstance(yaml_data, list)
                and yaml_data
                and all(isinstance(item, dict) for item in yaml_data)
            ):
                for key, value in item.items():
                    field_name = self._convert_to_snake_case(key)
                    if field_name not in field_types:
                        field_types[field_name] = []
                        field_found[field_name] = 1
                    else:
                        field_found[field_name] += 1
                    field_types[field_name].append(value)
            else:
                for key, value in yaml_data.items():
                    field_name = self._convert_to_snake_case(key)
                    if field_name not in field_types:
                        field_types[field_name] = []
                        field_found[field_name] = 1
                    else:
                        field_found[field_name] += 1
                    field_types[field_name].append(value)
        # add id field first
        fields["id"] = "models.IntegerField(primary_key=True)"
        for field_name, field_values in field_types.items():
            is_optional = len(yaml_data) != field_found[field_name]
            print(
                f"optional: {is_optional} | {field_name}: {field_found[field_name]} vs {len(yaml_data)}"
            )
            fields[field_name] = self._get_field_type(
                field_values[0], optional=is_optional
            )

        return fields
